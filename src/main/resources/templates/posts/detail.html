<!-- src/main/resources/templates/posts/detail.html -->
<!doctype html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>crudboard | Post Detail</title>
    <link rel="stylesheet" href="/css/posts.css">

    <!-- 댓글 UI를 위한 최소 보조 스타일(기존 posts.css를 해치지 않게 최소만) -->
    <style>
        .section { margin-top: 18px; padding-top: 18px; border-top: 1px solid rgba(0,0,0,.08); }
        .row { display:flex; gap:10px; align-items:center; }
        .grow { flex: 1; }
        .comment-form textarea {
            width: 100%;
            min-height: 90px;
            resize: vertical;
            padding: 10px 12px;
            border: 1px solid rgba(0,0,0,.15);
            border-radius: 10px;
            font: inherit;
            line-height: 1.35;
            background: #fff;
        }
        .comment-list { margin-top: 12px; display:flex; flex-direction: column; gap: 10px; }
        .comment-item {
            border: 1px solid rgba(0,0,0,.10);
            border-radius: 14px;
            padding: 12px 12px;
            background: rgba(255,255,255,.8);
        }
        .comment-top { display:flex; justify-content: space-between; align-items:center; gap: 10px; }
        .comment-meta { display:flex; gap: 8px; align-items:center; flex-wrap: wrap; }
        .comment-content { margin-top: 8px; white-space: pre-wrap; word-break: break-word; }
        .comment-actions { display:flex; gap: 8px; }
        .btn.small, button.small { padding: 8px 10px; border-radius: 10px; font-size: 13px; }
        .muted.small { font-size: 13px; }
        .pager.inline { display:flex; gap: 8px; justify-content:flex-end; margin-top: 12px; }
        .divider { height: 1px; background: rgba(0,0,0,.08); margin: 10px 0; }
    </style>
</head>

<body>
<div class="container">
    <div class="card" id="card">
        <header>
            <div>
                <h1 id="title">-</h1>
                <div class="meta">
                    <span class="pill" id="idPill">ID -</span>
                    <span class="pill" id="createdAt">created -</span>
                    <span class="pill" id="updatedAt">updated -</span>
                </div>
                <div class="muted" style="margin-top:8px;">내용</div>
            </div>
            <div class="actions">
                <a class="btn" href="/posts">목록</a>
                <a class="btn primary" id="editLink" href="#">수정</a>
                <button class="danger" id="deleteBtn">삭제</button>
            </div>
        </header>

        <div class="error" id="errorBox"></div>

        <pre id="content">-</pre>

        <!-- 댓글 섹션 -->
        <div class="section">
            <div class="row" style="justify-content: space-between;">
                <div>
                    <div style="font-weight: 700; font-size: 18px;">댓글</div>
                    <div class="muted small" id="commentSummary">-</div>
                </div>
                <div class="row">
                    <label class="muted small" for="commentSize">표시</label>
                    <select id="commentSize" class="small">
                        <option value="5">5개</option>
                        <option value="10" selected>10개</option>
                        <option value="20">20개</option>
                    </select>
                </div>
            </div>

            <div class="divider"></div>

            <!-- 댓글 작성 -->
            <div class="comment-form">
                <div class="muted small" style="margin-bottom:6px;">댓글 작성</div>
                <textarea id="commentInput" placeholder="댓글을 입력하세요 (최대 1000자)"></textarea>
                <div class="row" style="justify-content: flex-end; margin-top:10px;">
                    <button class="primary small" id="commentCreateBtn">등록</button>
                </div>
            </div>

            <!-- 댓글 목록 -->
            <div class="comment-list" id="commentList">
                <!-- injected -->
            </div>

            <div class="row" style="justify-content: space-between; margin-top: 12px;">
                <span class="pill" id="commentPageInfo">page - / -</span>
                <div class="pager inline">
                    <button class="small" id="commentPrevBtn">이전</button>
                    <button class="small" id="commentNextBtn">다음</button>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    // =========================
    // API 경로 (프로젝트에 맞게 조정 가능)
    // =========================
    const API = {
        post: (postId) => `/api/posts/${postId}`,
        deletePost: (postId) => `/api/posts/${postId}`,
        // 댓글 API (권장)
        comments: (postId) => `/api/posts/${postId}/comments`,
        deleteComment: (postId, commentId) => `/api/posts/${postId}/comments/${commentId}`,
    };

    // --- DOM ---
    const card = document.getElementById('card');
    const titleEl = document.getElementById('title');
    const contentEl = document.getElementById('content');
    const idPill = document.getElementById('idPill');
    const createdAtEl = document.getElementById('createdAt');
    const updatedAtEl = document.getElementById('updatedAt');
    const editLink = document.getElementById('editLink');
    const deleteBtn = document.getElementById('deleteBtn');
    const errorBox = document.getElementById('errorBox');

    // comments dom
    const commentSummary = document.getElementById('commentSummary');
    const commentSizeSelect = document.getElementById('commentSize');
    const commentInput = document.getElementById('commentInput');
    const commentCreateBtn = document.getElementById('commentCreateBtn');
    const commentList = document.getElementById('commentList');
    const commentPageInfo = document.getElementById('commentPageInfo');
    const commentPrevBtn = document.getElementById('commentPrevBtn');
    const commentNextBtn = document.getElementById('commentNextBtn');

    // --- Utils ---
    function setLoading(isLoading) {
        card.classList.toggle('loading', isLoading);
        deleteBtn.disabled = isLoading;
        commentCreateBtn.disabled = isLoading;
        commentPrevBtn.disabled = isLoading;
        commentNextBtn.disabled = isLoading;
    }

    function showError(message) {
        errorBox.style.display = 'block';
        errorBox.textContent = message;
    }

    function clearError() {
        errorBox.style.display = 'none';
        errorBox.textContent = '';
    }

    function fmtDate(iso) {
        if (!iso) return '-';
        return String(iso).replace('T', ' ').slice(0, 19);
    }

    function escapeHtml(str) {
        return String(str)
            .replaceAll('&', '&amp;')
            .replaceAll('<', '&lt;')
            .replaceAll('>', '&gt;')
            .replaceAll('"', '&quot;')
            .replaceAll("'", '&#039;');
    }

    function getIdFromPath() {
        // /posts/{id} 형태
        const parts = location.pathname.split('/').filter(Boolean);
        const last = parts[parts.length - 1];
        const id = Number(last);
        if (!Number.isFinite(id)) return null;
        return id;
    }

    // --- State ---
    const postId = getIdFromPath();
    const commentState = {
        page: 0,
        size: parseInt(commentSizeSelect.value, 10),
    };

    if (postId == null) {
        showError('잘못된 접근입니다. (id를 찾을 수 없음)');
        deleteBtn.disabled = true;
        commentCreateBtn.disabled = true;
        commentPrevBtn.disabled = true;
        commentNextBtn.disabled = true;
    } else {
        editLink.href = `/posts/${postId}/edit`;
    }

    // =========================
    // Post API
    // =========================
    async function fetchPost(id) {
        const res = await fetch(API.post(id), { headers: { 'Accept': 'application/json' } });
        if (!res.ok) {
            const text = await res.text().catch(() => '');
            throw new Error(`게시글 조회 실패 (${res.status})\n${text}`);
        }
        return await res.json();
    }

    async function deletePost(id) {
        const res = await fetch(API.deletePost(id), { method: 'DELETE' });
        if (res.status === 204) return;
        const text = await res.text().catch(() => '');
        throw new Error(`게시글 삭제 실패 (${res.status})\n${text}`);
    }

    function renderPost(post) {
        titleEl.textContent = post.title ?? '-';
        contentEl.textContent = post.content ?? '';
        idPill.textContent = `ID ${post.id ?? '-'}`;
        createdAtEl.textContent = `created ${fmtDate(post.createdAt)}`;
        updatedAtEl.textContent = `updated ${fmtDate(post.updatedAt)}`;
    }

    // =========================
    // Comment API
    // =========================
    async function fetchComments(postId, state) {
        const params = new URLSearchParams();
        params.set('page', String(state.page));
        params.set('size', String(state.size));
        // 서버에서 기본 정렬을 걸어뒀다면 생략 가능. 필요하면 아래 주석 해제:
        // params.set('sort', 'createdAt,desc');

        const res = await fetch(`${API.comments(postId)}?${params.toString()}`, {
            headers: { 'Accept': 'application/json' }
        });
        if (!res.ok) {
            const text = await res.text().catch(() => '');
            throw new Error(`댓글 조회 실패 (${res.status})\n${text}`);
        }
        return await res.json();
    }

    async function createComment(postId, content) {
        const res = await fetch(API.comments(postId), {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
            },
            body: JSON.stringify({ content }),
        });

        // 보통 201 Created (또는 200 OK) 가능
        if (res.status === 201 || res.status === 200) return await res.json().catch(() => ({}));

        const text = await res.text().catch(() => '');
        throw new Error(`댓글 등록 실패 (${res.status})\n${text}`);
    }

    async function deleteComment(postId, commentId) {
        const res = await fetch(API.deleteComment(postId, commentId), { method: 'DELETE' });

        // 보통 204 No Content
        if (res.status === 204) return;

        const text = await res.text().catch(() => '');
        throw new Error(`댓글 삭제 실패 (${res.status})\n${text}`);
    }

    function renderComments(pageResponse) {
        commentList.innerHTML = '';

        const rows = pageResponse.content ?? [];
        if (rows.length === 0) {
            const empty = document.createElement('div');
            empty.className = 'muted';
            empty.style.padding = '12px 6px';
            empty.textContent = '댓글이 없습니다.';
            commentList.appendChild(empty);
            return;
        }

        for (const c of rows) {
            const item = document.createElement('div');
            item.className = 'comment-item';

            const id = c.id ?? null;
            const createdAt = c.createdAt ?? null;
            const updatedAt = c.updatedAt ?? null;
            const content = c.content ?? '';

            item.innerHTML = `
        <div class="comment-top">
          <div class="comment-meta">
            <span class="pill">#${id ?? '-'}</span>
            <span class="muted small">created ${escapeHtml(fmtDate(createdAt))}</span>
            <span class="muted small">updated ${escapeHtml(fmtDate(updatedAt))}</span>
          </div>
          <div class="comment-actions">
            <button class="danger small" data-action="delete" data-id="${id ?? ''}">삭제</button>
          </div>
        </div>
        <div class="comment-content">${escapeHtml(content)}</div>
      `;

            // 삭제 핸들러
            const delBtn = item.querySelector('button[data-action="delete"]');
            delBtn.addEventListener('click', async (e) => {
                e.stopPropagation();
                if (id == null) return;

                const ok = confirm('댓글을 삭제할까요?');
                if (!ok) return;

                clearError();
                setLoading(true);
                try {
                    await deleteComment(postId, id);
                    // 현재 페이지에서 삭제 후 비어버리면 한 페이지 당겨주는 UX
                    // (예: 마지막 댓글을 삭제해서 현재 페이지가 텅 빈 경우)
                    const after = await fetchComments(postId, commentState);
                    if ((after.content?.length ?? 0) === 0 && commentState.page > 0) {
                        commentState.page -= 1;
                    }
                    await loadComments();
                } catch (err) {
                    showError(err?.message ?? String(err));
                } finally {
                    setLoading(false);
                }
            });

            commentList.appendChild(item);
        }
    }

    function renderCommentMeta(pageResponse) {
        const totalElements = pageResponse.totalElements ?? 0;
        const totalPages = pageResponse.totalPages ?? 0;
        const number = pageResponse.number ?? commentState.page;
        const size = pageResponse.size ?? commentState.size;
        const numberOfElements = pageResponse.numberOfElements ?? (pageResponse.content?.length ?? 0);

        commentSummary.textContent = `총 ${totalElements}개 · 현재 ${numberOfElements}개 표시`;
        commentPageInfo.textContent = `page ${number + 1} / ${Math.max(totalPages, 1)} · size ${size}`;

        const first = pageResponse.first ?? (number <= 0);
        const last = pageResponse.last ?? (totalPages > 0 ? number >= totalPages - 1 : true);

        commentPrevBtn.disabled = first;
        commentNextBtn.disabled = last;
    }

    // =========================
    // Loaders
    // =========================
    async function loadPost() {
        const post = await fetchPost(postId);
        renderPost(post);
    }

    async function loadComments() {
        const data = await fetchComments(postId, commentState);
        renderComments(data);
        renderCommentMeta(data);
    }

    async function loadAll() {
        if (postId == null) return;

        clearError();
        setLoading(true);
        try {
            await loadPost();
            await loadComments();
        } catch (e) {
            showError(e?.message ?? String(e));
            // 실패 시 최소 상태 복구
            titleEl.textContent = '-';
            contentEl.textContent = '';
            deleteBtn.disabled = true;
            commentCreateBtn.disabled = true;
            commentPrevBtn.disabled = true;
            commentNextBtn.disabled = true;
            commentList.innerHTML = '';
            commentSummary.textContent = '-';
            commentPageInfo.textContent = 'page - / -';
        } finally {
            setLoading(false);
        }
    }

    // =========================
    // Events
    // =========================
    deleteBtn.addEventListener('click', async () => {
        if (postId == null) return;

        const ok = confirm('정말 게시글을 삭제할까요?');
        if (!ok) return;

        clearError();
        setLoading(true);
        try {
            await deletePost(postId);
            location.href = '/posts';
        } catch (e) {
            showError(e?.message ?? String(e));
        } finally {
            setLoading(false);
        }
    });

    commentCreateBtn.addEventListener('click', async () => {
        if (postId == null) return;

        const content = (commentInput.value ?? '').trim();
        if (content.length === 0) {
            alert('댓글 내용을 입력해주세요.');
            return;
        }
        if (content.length > 1000) {
            alert('댓글은 최대 1000자까지 입력할 수 있어요.');
            return;
        }

        clearError();
        setLoading(true);
        try {
            await createComment(postId, content);
            commentInput.value = '';
            // 등록하면 첫 페이지로 보이게(최신순 정렬 기준일 때 UX 좋음)
            commentState.page = 0;
            await loadComments();
        } catch (e) {
            showError(e?.message ?? String(e));
        } finally {
            setLoading(false);
        }
    });

    commentInput.addEventListener('keydown', (e) => {
        // Ctrl+Enter로 등록
        if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
            commentCreateBtn.click();
        }
    });

    commentSizeSelect.addEventListener('change', async () => {
        commentState.size = parseInt(commentSizeSelect.value, 10);
        commentState.page = 0;
        clearError();
        setLoading(true);
        try {
            await loadComments();
        } catch (e) {
            showError(e?.message ?? String(e));
        } finally {
            setLoading(false);
        }
    });

    commentPrevBtn.addEventListener('click', async () => {
        commentState.page = Math.max(0, commentState.page - 1);
        clearError();
        setLoading(true);
        try {
            await loadComments();
        } catch (e) {
            showError(e?.message ?? String(e));
        } finally {
            setLoading(false);
        }
    });

    commentNextBtn.addEventListener('click', async () => {
        commentState.page = commentState.page + 1;
        clearError();
        setLoading(true);
        try {
            await loadComments();
        } catch (e) {
            showError(e?.message ?? String(e));
        } finally {
            setLoading(false);
        }
    });

    // initial load
    loadAll();
</script>
</body>
</html>